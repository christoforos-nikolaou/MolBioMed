---
title: "Κεφάλαιο 3. Τύποι Δεδομένων"
author: "Χριστόφορος Νικολάου"
date: '`r Sys.Date()`'
output:
  html_document:
    code_folding: show
    fig_caption: yes
    toc: yes
    toc_depth: 3
    toc_float: yes
  pdf_document:
    latex_engine: xelatex
  word_document: null
link-citations: yes
header-includes:
- \usepackage[greek]{babel}
- \usepackage{fontspec}
- \usepackage{xunicode}
- \usepackage{xgreek}
- \usepackage{polyglossia}
- \setmainlanguage{greek}
- \setmainfont[Ligatures=TeX]{Linux Libertine O}
- \newfontfamily\greekfonttt[Script=Greek]{Linux Libertine O}
bibliography: null
---


## Εισαγωγή
Στο προηγούμενο Κεφάλαιο είδαμε πως δημιουργούμε απλές μεταβλητές αλλά και πώς μπορούμε να φορτώσουμε στην R πιο σύνθετα αντικείμενα με δομή που περιέχει περισσότερες από μία μεταβλητές. Η R υποστηρίζει τη δημιουργία και ανάλυση διαφορετικών σε δομή και οργάνωση συνόλων δεδομένων, για καθένα από τα οποία υπάρχουν συγκεκριμένες συναρτήσεις. Μέσω της R επίσης είναι δυνατή η μετατροπή κάποιων τύπων δεδομένων σε άλλους αν και όπως θα δούμε αυτό θα πρέπει να γίνεται με προσοχή. 
Στο συγκεκριμένο Κεφάλαιο θα περιγράψουμε αναλυτικά τους τύπους αντικειμένων δεδομένων (data types) στην R. Στην συνέχεια θα δούμε κάποιους βασικούς χειρισμούς με τους οποίους ελέγχουμε τη δομή και την πληρότητα των αντικειμένων αυτών καθώς και τρόπους για να πραγματοποιήσουμε μετατροπές μεταξύ διαφορετικών τύπων. Τέλος, θα δούμε πώς μπορούμε να εξαγάγουμε υποσύνολα δεδομένων από αντικείμενα είτε εκμεταλλευόμενοι τη δομή τους, είτε εφαρμόζοντας λογικούς ελέγχους.

## Τύποι δεδομένων στην R
Οι απλές μεταβλητές που είδαμε στο προηγούμενο μάθημα δεν είναι παρά οι συστατικές μονάδες πιο σύνθετων αντικειμένων όταν μιλάμε για ανάλυση δεδομένων. Οι κύριες δομές των αντικειμένων δεδομένων είναι:  

1. Τα **Διανύσματα** (vectors)  
2. Οι **Πίνακες δύο Διαστάσεων** (matrices)  
3. Τα **Πλαίσια Δεδομένων** (data frames)  
4. Οι **Πολυδιάστατοι Πίνακες** (arrays/tables)  
5. Οι **Λίστες** (lists)  

Τα ονόματά τους ενδέχεται να είναι παραπλανητικά σε σχέση με την πραγματική δομή τους. Έτσι π.χ. οι πίνακες τύπου array/table είναι πιο πολύπλοκοι από τους πίνακες τύπου matrix, ενώ οι λίστες (lists) είναι τα πιο σύνθετα αντικείμενα σε αντίθεση με αυτό που ίσως υποδηλώνει το όνομά τους. Όπως αναφέραμε στο προηγούμενο Κεφάλαιο, ανάλογα με τον τύπο των δεδομένων η R υποστηρίζει διαφορετικές συναρτήσεις. Έτσι, στη συνέχεια θα εξετάσουμε πιο αναλυτικά καθέναν από τους παραπάνω σε συνδυασμό με τις αντίστοιχες, βασικές συναρτήσεις χειρισμού τους.

## 3.1 Διανύσματα (vectors)

### 3.1.1 Γενικά χαρακτηριστικά διανυσμάτων

Τα διανύσματα είναι απλά μονοδιάστατα αντικείμενα που περιέχουν στοιχεία του ίδιου είδους. Θυμηθείτε ότι τα είδη (types) που συζητήσαμε στο προηγούμενο μάθημα είναι αριθμητικές, αλφαριθμητικές ή λογικές μεταβλητές. Μπορούμε να δημιουργήσουμε ένα διάνυσμα συνδέοντας μεταβλητές του ίδιου είδους με τη χρήση μιας βασικής συνάρτησης που ονομάζεται $c()$ και συμβολίζει τη συνένωση (concatenation). Η χρήση της $c()$ γίνεται με την εισαγωγή των μεταβλητών ως ορισμάτων διαχωρισμένων με κόμμα:

```{r, eval=T, echo=T}
vec<-c(1,2,5,3.14,8)
vec
```

Στο παραπάνω παράδειγμα όλες οι μεταβλητες είναι αριθμητικές κι έτσι το είδος του αντικειμένου είναι numeric όπως προκύπτει τόσο από τον έλεγχο του είδους $class()$ όσο και με τη διερεύνηση της δομέης του με την $str()$:

```{r, eval=T, echo=T}
class(vec)
str(vec)
```

Η $str()$ δεν μας δίνει μόνο το είδος των μεταβλητών που περιέχει το διάνυσμα $vec$ αλλά μας επιστρέφει και το μέγεθός του. Πρόκειται για ένα διάνυσμα 5 τιμών όπως φαίνεται από τις τιμές στην αγκύλη [1:5], που σημαίνει ότι τα στοιχεία ξεκινούν από το 1 και φτάνουν ως το 5. Στην R η αρίθμηση ξεκινάει από το 1 (one-based) κι έτσι μπορούμε να αναφερθούμε στο 4ο στοιχείο του διανύσματος $vec$ ως εξής:

```{r}
vec[4]
```

Οι αγκύλες είναι ο τρόπος με τον οποίο μπορούμε να αναφερθούμε σε επιμέρους στοιχεία αντικειμένων, τόσο διανυσμάτων όσο και πινάκων και λιστών όπως θα δούμε στη συνέχεια. Γενικά για τα διανύσματα, μπορούμε να αντιμετωπίσουμε τις αγκύλες ως μια συνάρτηση της οποίας το όρισμα είναι ένα διάνυσμα που είναι υποχρεωτικά αριθμητικό ακέραιου είδους. Έτσι οι αγκύλες μπορούν να δεχτούν σύνολα τιμών όπως:

```{r}
vec[c(1,2,3)]
```

Συνεχόμενες αριθμητικές τιμές μπορούν να δοθούν με τον τελεστή ":" που δημιουργεί μια σειρά ακέραιων αριθμών από $a$ έως $b$ αν γράψουμε $a:b$. Στις επόμενες εντολές αρχικά δημιουργούμε τη σειρά αριθμών από το 1 έως το 4 και μετά παίρνουμε από το διάνυσμα $vec$ τις τιμές που αντιστοιχούν στις θεσεις 1 έως 4:

```{r}
x<-1:4
vec[x]
```

Οι αριθμοί που δίνονται σαν όρισμα στις αγκύλες δεν είναι υποχρεωτικό να δίνονται με αύξουσα σειρά και μπορούν να επαναλαμβάνονται. Ο μοναδικός περιορισμός είναι να μην ξεπερνούν το συνολικό μήκος του διανύσματος. Το τελευταίο δίνεται σε μια μεταβλητή με την εφαρμογή της συνάρτησης $length()$. Στις επόμενες εντολές δίνουμε το μήκος του $vec$ σε μια μεταβλητή, στη συνέχεια δημιουργούμε μια σειρά αριθμών από το 3 έως το μήκος αυτό και ζητάμε από το $vec$ τα στοιχεία που αντιστοιχούν σε αυτά:

```{r}
l<-length(vec)
i<-3:l
vec[i]
```

To αποτέλεσμα λογικά είναι οι τιμές του 3ου, 4ου και 5ου στοιχείου του $vec$. Η διαδικασία που μόλις εξετάσαμε είναι ουσιαστικά ένα είδος "λήψης υποσυνόλου" την οποία θα εξετάσουμε πιο αναλυτικά αργότερα. Μια τελευταία λειτουργία δεικτών σε αγκύλη που αξίζει να εξετάσουμε είναι η λήψη του συμπληρωματικού συνόλου με τη χρήση του τελεστή "-" πριν από το διάνυσμα που μπαίνει σε αγκύλες. Έτσι αν στην παραπάνω αντικαταστήσουμε το $i$ με το $-i$ τότε παίρνουμε το σύνολο των τιμών του $vec$ που _δεν_ αντιστοιχούν σε $i$.

```{r}
vec[-i]
```



### 3.1.2 Δημιουργία διανυσμάτων και "εξαναγκασμός" (coersion)

Οι ίδιες αρχές διέπουν τόσο τα αριθμητικά όσο και τα αλφαριθμητικά και λογικά διανύσματα. Η δημιουργία διαφορετικών τύπων μπορεί να γίνει με τυπική δήλωση του είδους τους με τις συναρτήσεις $numeric()$, $character()$ και $logical()$ οι οποιες δημιουργούν κενά διανύσματα συγκεκριμένου μήκους που δίνεται ως όρισμά τους:

```{r}
numvec<-numeric(10) # default value is 0
chrvec<-character(10) # default value is ""
logvec<-logical(10) # default value is FALSE
```

Εναλλακτικά υπάρχει η πιο δομημένη συνάρτηση $vector()$ που δέχεται ως ορίσματα τον τύπο και το μέγεθος του διανύσματος. Τα παραπάνω διανύσματα μπορούν όλα να δημιουργηθούν με τις παρακάτω παραλλαγές αυτής της συνάρτησης:

```{r}
numvec<-vector(mode="numeric", length=10)
chrvec<-vector(mode="character", length=10)
logvec<-vector(mode="logical", length=10)
```

Ένας τρίτος τρόπος δημιουργίας διανυσμάτων είναι με την απευθείας απόδοση τιμών όπως είδαμε παραπάνω. Η απευθείας απόδοση τιμών χρειάζεται προσοχή λόγω μιας βασικής λειτουργίας της R που λέγεται "εξαναγκασμός" (coersion) και που μετατρέπει το είδος της μεταβλητής ανάλογα με μια σειρά προτεραιότητας που είναι: χαρακτήρες, αριθμοί, λογικές τιμές. Για να καταλάβετε καλύτερα τον εξαναγκασμό δείτε το παρακάτω παράδειγμα όπου ένα διάνυσμα ορίζεται ως μίγμα χαρακτήρων και λογικών τιμών:

```{r}
unknown<-c("variable1", "variable2", FALSE, TRUE, TRUE)
str(unknown)
```

Προσέξτε ότι παρότι στην εκχώρηση των μεταβλητών περιέχονται δύο αλφαριθμητικά και τρεις λογικές τιμές, οι τελευταίες δεν λογίζονται ως τέτοιες, παρά μετατρέπονται σε αλφαριθμητικά ως σειρές χαρακτήρων. Αυτό συμβαίνει αφενός γιατί ένα διάνυσμα δεν μπορεί να περιέχει διαφορετικά είδη μεταβλητών και αφετέρου γιατί η προτεραιότητα εξαναγκασμού είναι προς τα αλφαριθμητικά. Το ίδιο συμβαίνει και στις παρακάτω περιπτώσεις:

```{r}
unknown<-c("variable1", "variable2", 1, 5, 3.14)
str(unknown)
#
unknown2<-c(FALSE, TRUE, 1, 5, -8)
str(unknown2)
```

Στην πρώτη περίπτωση οι χαρακτήρες υπερισχύουν των αριθμητικών και τα μετατρέπουν σε χαρακτήρες. Προσέξτε ότι πλέον οι αριθμοί 1, 5, 3.14 βρίσκονται μέσα σε εισαγωγικά και ως εκ τούτου η R θα τους χειριστεί ως χαρακτήρες. Στη δεύτερη περίπτωση, η προτεραιότητα δίνεται στους αριθμούς κι έτσι οι τιμές FALSE, TRUE μετατρέπονται σε αριθμούς με βάση τη σύμβαση F=0, T=1.  
Παρά την ευελιξία που προσδίδει ο εξαναγκασμός μπορεί συχνά να οδηγήσει σε προβλήματα καθώς αν τα δεδομένα που διαβάζουμε δεν είναι "καθαρά" μπορεί να αλλάξει το είδος των μεταβλητών που νομίζουμε ότι αναλύουμε. Για παράδειγμα αρκεί ένα τυπογραφικό σφάλμα σε ένα αριθμητικό διάνυσμα για να το μετατρέψει σε διάνυσμα χαρακτήρων.

### 3.1.3 Εξωτερικός "εξαναγκασμός" από τον χρήστη. 
Σε κάποιες περιπτώσεις επιθυμούμε τη μετατροπή δεδομένων σε ένα συγκεκριμένο είδος αν και ως πρακτική είναι σχετικά επικίνδυνη και είναι καλό να γίνεται με προσοχή και πάντα με επαλήθευση. Ο επιβαλλόμενος εξαναγκασμός (forced coersion) γίνεται με τις συναρτήσεις τύπου $as.X()$ όπου Χ=numeric, character, logical κλπ, οι οποίες μετατρέπουν διανύσματα ενός είδους στο είδος που ορίζει η συνάρτηση. Στο παράδειγμα:

```{r}
logvec<-c(T,T,F,F,T,T,F)
str(logvec)
as.numeric(logvec)
as.character(logvec)
```

το λογικό διάνυσμα $logvec$ μετατρέπεται αρχικά σε αριθμητικό με την $as.numeric()$ με την αντιστοίχηση F=0, T=1 και στη συνέχεια σε αλφαριθμητικό με την $as.character()$.
Αντίστοιχα, μετατροπή αριθμητικών είναι δυνατή τόσο σε λογικές τιμές όσο και σε αλφαριθμητικά. Η μετατροπή σε λογικές τιμές γίνεται με την σύμβαση οι μηδενικές τιμές να ισούνται με F και *όλες* οι άλλες σε Τ. Η μετατροπή σε αλφαριθμητικά γίνεται με απλή χρήση εισαγωγικών:

```{r}
numvec<-c(4,-1.75,3,0,2.7,100,0)
str(numvec)
as.logical(numvec)
as.character(numvec)
```

Σημειώστε εδώ ότι δεν είναι επιτρεπτές όλες οι μετατροπές. Έτσι είναι δυνατή η μετατροπή τόσο λογικών όσο και αριθμητικών σε αλφαριθμητικά με απλή χρήση εισαγωγικών. Ωστόσο δεν είναι δυνατή η αντίθετη μετατροπή:

```{r}
chrvec<-c("steven","kenny","robbie","ian","fernando")
str(chrvec)
as.numeric(chrvec)
as.logical(chrvec)
```

Συγκεκριμένα και στις δύο περιπτώσεις η μετατροπή οδηγεί στη δημιουργία διανυσμάτων που περιέχουν μη-αποδιδόμενες (not assigned) τιμές. Η τιμή ΝΑ (χωρίς διπλά εισαγωγικά) αντιστοιχεί στην τιμή που δίνει η R για ελλιπείς τιμές. 
Στη συνέχεια του Κεφαλαίου θα επανέλθουμε στις NA τιμές και στο χειρισμό τους.

### 3.1.4 Συναρτήσεις Διανυσμάτων

#### 3.1.4.1 Συναρτήσεις Αριθμητικών Διανυσμάτων
Πέρα από τη συνάρτηση δημιουργίας $numeric()$ οι βασικές συναρτήσεις των αριθμητικών διανυσμάτων είναι οι εξής:
  
1. $length()$: Μέγεθος, ή μήκος, δηλαδή το πλήθος των στοιχείων ενός διανύσματος:
```{r}
vec<-c(1, 8, 9, 10, -4, 2.8, 10)
length(vec)
```
  
2. $max(), min()$: Μέγιστη/Ελάχιστη τιμή.
```{r}
max(vec)
min(vec)
```
  
3. $rev()$: Αντιστροφή σειράς των στοιχείων του διανύσματος:
```{r}
vec
rev(vec)
```
  
4. $sort()$: Κατάταξη (με αύξουσα ή φθίνουσα σειρά):
```{r}
vec
sort(vec) # default αύξουσα σειρά
sort(vec, decreasing = T) # φθίνουσα σειρά
```
  
5. $order()$: Θέση κατάταξης. Δίνει τη **θέση στην κατάταξη** κατά αύξουσα σειρά κρατώντας όμως τη σειρά των στοιχείων σταθερή. Προσέξτε το παράδειγμα:
```{r}
vec<-c(1, 8, 9, 10, -4, 2.8, 10)
order(vec)
```

To οποίο σημαίνει ότι το 5ο στοιχείο (-4) είναι πρώτο σε αύξουσα σειρά κατάταξής, το 1ο (1) δεύτερο κ.ο.κ. Το διάνυσμα που προκύπτει από την εφαρμογή της $ord()$ μπορεί να εφαρμοστεί στο διάνυσμα ως δείκτης και από αυτό να προκύψει ένα διατεταγμένο διάνυσμα. Συγκρινετε τα παρακάτω:

```{r}
vec<-c(1, 8, 9, 10, -4, 2.8, 10)
ord<-order(vec)
vec[ord]
#
sort(vec)
```

6. $rank()$: Τιμή κατάταξης. Δίνει τη **τιμή στην κατάταξη** κατά **αύξουσα** σειρά. 
```{r}
vec<-c(1, 8, 9, 10, -4, 2.8, 10)
rank(vec)
```
Στην τυπική (default) εκδοχή της η $rank()$ "μοιράζει" την κατάταξη μεταξύ των στοιχείων που ισοβαθμούν. Έτσι στο παράδειγμα δεν υπάρχει στοιχείο με κατάταξη 6 ή 7 (και τα δύο έχουν την τιμή 10.0) οπότε τους αποδίδεται η τιμή 6.5.
Αν θέλουμε να έχουμε ακέραιες τιμές κατάταξης τροποποιούμε την παράμετρο $ties.method$:

```{r}
vec<-c(1, 8, 9, 10, -4, 2.8, 10)
rank(vec, ties.method = "first")
```


#### 3.1.4.2 Συναρτήσεις Αλφαριθμητικών Διανυσμάτων

Οι περισσότερες γενικές συναρτήσεις που σχετίζονται με τη δομή των διανυσμάτων ισχύουν εξίσου και για τα αλφαριθμητικά διανύσματα. Έτσι τόσο η $length()$, όσο και οι $rev()$, $sort()$, $ord()$, $rank()$ λειτουργούν κανονικά εφαρμόζοντας αλφαβητική σειρά κατάταξης για τα αλφαριθμητικά (και F, T για τις λογικές τιμές). 

1. Μέγεθος, ή μήκος, δηλαδή το πλήθος των στοιχείων ενός διανύσματος:
```{r}
vec<-c("nick", "mike", "eve", "laura", "george")
length(vec)
```
  
2. Αντιστροφή σειράς των στοιχείων του διανύσματος:
```{r}
vec
rev(vec)
```
  
3. Κατάταξη (με αύξουσα ή φθίνουσα σειρά):
```{r}
vec
sort(vec) # default αύξουσα σειρά
sort(vec, decreasing = T) # φθίνουσα σειρά
```

Ειδικές συναρτήσεις που βρίσκουν εφαρμογή σε διανύσματα αλφαριθμητικών είναι γενικά οι συναρτήσεις που δρουν σε σειρές χαρακτήρων. Οι κυριότερες είναι:  

1. $toupper()$ και $tolower()$ για μετατροπή σε κεφαλαία ή πεζά αντίστοιχα:
```{r}
toupper(vec)
```
  
2. Αποκοπή στοιχείων από μια σειρά χαρακτήρων με τη συνάρτηση $substr()$. H εφαρμογή της συνάρτησης χρειάζεται τρία ορίσματα, τη σειρά χαρακτήρων, καθώς και το σημείο έναρξης και λήξης που θα κρατηθούν. Στο παράδειγμα:
```{r}
substr(vec, 1, 2)
```
οι χαρακτήρες του $vec$ κόβονται σε μικρότερες σειρές που ξεκινούν από το πρώτο γράμμα (1) και φτάνουν ως το δεύτερο. Αντίστοιχα θα μπορούσαμε να ξεκινήσουμε από επόμενο χαρακτήρα και να πάμε ως τον 5ο χαρακτήρα (όπου αυτός υπάρχει):
```{r}
substr(vec, 2, 5)
```
  
3. Μπορούμε να "κόψουμε" τους χαρακτήρες χρησιμοποιώντας συγκεκριμένα σύμβολα/γράμματα ως διαχωριστές με τη χρήση της $strsplit():
```{r}
strsplit(vec, "i")
```
Η $strsplit()$ παίρνει σαν όρισμα το διάνυσμα χαρακτήρων και το σύμβολο διαχωριστή (εδώ "i"). Το αποτέλεσμα είναι μια λίστα από σειρές χαρακτήρων, κάθε στοιχείο της οποίας είναι αποτέλεσμα του διαχωρισμού κάθε στοιχείου του $vec$ στο σύμβολο "i" (περισσότερα για τις λίστες στη συνέχεια).

Και στα τρία παραπάνω παραδείγματα βλέπουμε ότι οι συναρτήσεις εφαρμόζονται πάνω σε διανύσματα δίνοντας ως αποτέλεσμα νέα διανύσματα. Οι πράξεις δηλαδή εφαρμόζονται επαναληπτικά σε όλα τα στοιχεία του διανύσματος. Η διανυσματική εφαρμογή (vectorial processing) είναι ένα βασικό πλεονέκτημα της R και ένα βασικό χαρακτηριστικό που την καθιστά ταχύτατη και εξαιρετικά εύχρηστη. Στη συνέχεια θα δούμε αυτό το χαρακτηριστικό πιο αναλυτικά. 

## 3.2 Πράξεις σε Διανύσματα
Στο επίπεδο των υπολογισμών η μεγάλη δύναμη της R συνίσταται στη διανυσματική εφαρμογή συναρτήσεων. Οι δυνατότητες που προσφέρει φαίνονται καλύτερα αν αναλογιστούμε τις διαφορές στην εκτέλεση αλλά και στην κωδικοποίηση διαδικασιών σε διανύσματα μεταξύ της R και μιας άλλης γλώσσας.
Έστω το αριθμητικό διάνυσμα:

```{r, echo=T, eval=T}
values<-seq(from=1, to=100, by=2)
```

το οποίο δημιουργούμε με τη χρήση μιας συνάρτησης που ονομάζεται $seq()$ και παίρνει τρία ορίσματα (αρχή, τέλος, βήμα προόδου). Η συνάρτηση αποδίδει τους όρους μιας αριθμητικής προόδου. Έστω τώρα ότι θέλουμε να υπολογίσουμε την τετραγωνική ρίζα όλων των τιμών του διανύσματος. Σε μια τυπική προγραμματική διαδικασία αυτό θα περιλάμβανε μια δομή επανάληψης που θα έπαιρνε κάθε στοιχείο του διανύσματος, θα εφάρμοζε την αντίστοιχη συνάρτηση και θα αποθήκευε το αποτέλεσμα σε ένα στοιχείο ενός νέου διανύσματος. Η R επιτρέπει μια τέτοια διαδικασία που θα μπορούσε να είναι η παρακάτω:

```{r, eval=T, echo=T}
sr_values<-vector(mode="numeric", length=length(values))
for(i in 1:length(values)){
  sr_values[i]<-sqrt(values[i])
}
```

Οι παραπάνω γραμμές κώδικα είναι λίγο πολύπλοκες γι' αυτό το στάδιο οπότε ας τις αναλύσουμε λίγο περισσότερο. 
Η πρώτη γραμμή δημιουργεί ένα νέο διάνυσμα με τη συνάρτηση $vector()$, καθορίζοντας το είδος (numeric) και το μέγεθός του με τη χρήση του length. Επειδή θα αποθηκεύσει τις τετραγωνικές ρίζες του values, ορίζουμε ίδιο μέγεθος (length=length(values)).
Η δεύτερη γραμμή εισάγει την επαναληπτική δομή με τη χρήση της εντολής $for$. Η σύνταξη της $for$ χρησιμοποιεί μια γυμνή μεταβλητη $i$ που είναι ο δείκτης της επανάληψης και παίρνει τιμές από το 1 έως το μήκος του διανύσματος $values$. H $for$ εισάγει τα όρια του δείκτη σε παρένθεση και στη συνέχεια, μέσα σε άγκιστρα παρατίθενται οι πράξεις/διαδικασίες που θα πραγματοποιηθούν σε κάθε βήμα της επανάληψης. Στην περίπτωσή μας η πράξη είναι μια απλή κλήση της συνάρτησης $sqrt()$ που υπολογίζει την τετραγωνική ρίζα του κάθε στοιχείου του $values$ και την αποδίδει στο αντίστοιχο στοιχείο του $sr_values$. O δείκτης $i$ εξασφαλίζει ότι το i-οστο στοιχείο του $sr_values$ θα παραλάβει την τετραγωνική ρίζα του i-οστού στοιχείου του $values$. 

H παραπάνω διαδικασία είναι αυτό που θα χρειαζόταν να κάνουμε σε μια γλώσσα που δεν υποστηρίζει διανυσματική εφαρμογή. Ο βρόχος (loop) επανάληψης θα ήταν απαραίτητος και ανάλογα με τον αριθμό των υπολογισμών, την πολυπλοκότητά τους και το μέγεθος των εμπλεκόμενων διανυσμάτων θα μπορούσε να είναι και αρκετά χρονοβόρος. Ωστόσο στην R η ίδια διαδικασία μπορεί να γίνει με μια απλή εντολή όπως η παρακάτω:

```{r, echo=T, eval=T}
sr_values<-sqrt(values)
```

την εφαρμογή δηλαδή της συνάρτησης _απευθείας_ πάνω στο διάνυσμα. Η διανυσματική εφαρμογή επεκτείνεται πέρα από τις συναρτήσεις και στις αριθμητικές πράξεις:

```{r, echo=T, eval=T}
sr_values<-sqrt(values)
new_values<-2*sr_values
```

Μέσω της διανυσματικής εφαρμογής, οι συναρτήσεις διενεργούν πράξεις μεταξύ διανυσμάτων με μεγαλύτερη ταχύτητα, ευκολία για τον χρήστη και καλύτερη διαχείριση της μνήμης. Μεταξύ μιας δομής επανάληψης και μιας διανυσματικής εφαρμογής είναι πάντοτε προτιμότερη η δεύτερη και παρόλο που θα δούμε τη διαδικασία σύνταξης βρόχων επανάληψης πιο αναλυτικά σε επόμενο κεφάλαιο, είναι γενικά καλό να αποφεύγονται αν μπορούν να αντικατασταθούν από πράξεις σε διανύσματα. Στη συνέχεια αυτού του κεφαλαίου θα δούμε πώς μπορούμε να εφαρμόσουμε και πιο πολύπλοκες συναρτήσεις με διανυσματική εφαρμογή με τη χρήση βοηθητικών συναρτήσεων της κατηγορίας $apply()$. 

## 3.3 Πίνακες δύο διαστάσεων

Οι πίνακες δύο διαστάσεων στην R ονομάζονται matrices και σχηματίζονται με δεδομένα σε σειρές και στήλες. Ένας βασικός περιορισμός των πινάκων δύο διαστάσεων είναι ότι τα δεδομένα πρέπει να είναι του ίδιου τύπου σε όλες τις στήλες του πίνακα, κάτι που τους διαφοροποιεί από τα πλαίσια δεδομένων που θα δούμε στη συνέχεια. Οι πίνακες σχηματίζονται με τη χρήση της συνάρτησης $matrix()$ που παίρνει σαν παραμέτρους τις τιμές του πίνακα σε ένα διάνυσμα, μαζί με τις διαστάσεις του πίνακα, τον τρόπο διάρθρωσης του διανύσματος και προαιρετικά τα ονόματα των γραμμών και στηλών του.

```{r}
values<-seq(1:20)
matrix(values, nrow=4, ncol=5, byrow=T)
```

Στο συγκεκριμένο παράδειγμα η παράμετρος $byrow$ έχει πάρει την τιμή Τ που σημαίνει ότι οι τιμές του διανύσματος (που είναι από το 1 ως το 20) τοποθετούνται στον πίνακα γεμίζοντας κάθε γραμμή. Η default λειτουργία της $matrix$ είναι οι τιμές να τοποθετούνται γεμίζοντας τις στήλες κι έτσι αν αφαιρεθεί αυτή η παράμετρος:

```{r}
matrix(values, nrow=4, ncol=5)
```

οι τιμές τοποθετούνται στον πίνακα γεμίζοντας τις στήλες. Το ίδιο θα συνέβαινε προφανώς αν είχαμε ζητήσει $byrow=F$. Είναι επίσης προφανές ότι το διάνυσμα των τιμών που θα δοθεί στην $matrix$ πρέπει να είναι ακριβές υποπολλαπλάσιο του γινόμενου των διαστάσεων του πίνακα. Αν είναι μικρότερο, αλλά όχι ακριβές υποπολλαπλάσιο ή μεγαλύτερο, τότε η $matrix$ επιστρέφει σφάλμα απόδοσης τιμών.

```{r}
values<-seq(1:30)
matrix(values, nrow=4, ncol=5, byrow=T)
```

Ένας πίνακας μπορεί να αρχικοποιηθεί με μια ουδέτερη τιμή, η οποία επαναλαμβανόμενη δημιουργεί έναν πίνακα ουδέτερων στοιχείων που μπορεί να είναι αριθμητικός:

```{r}
matrix(0, nrow=2, ncol=3, byrow=T)
```

χαρακτήρων

```{r}
matrix("", nrow=2, ncol=3, byrow=T)
```

ή λογικών τιμών:

```{r}
matrix(F, nrow=4, ncol=2)
```

### 3.3.1 Πρόσβαση σε στοιχεία πινάκων

Σε απόλυτη αναλογία με τα διανύσματα, των οποίων τα στοιχεία έχουν κατάταξη σε μία διάσταση, τα στοιχεία των matrices καθορίζονται με δύο τιμές που αντιστοιχούν στις συντεταγμένες γραμμής, στήλης και που δίνονται μέσα σε αγκύλες με αντίστοιχη σειρά. Έτσι π.χ. το στοιχείο του πίνακα $mat$ που βρίσκεται στην πρώτη γραμμή και την τρίτη στήλη είναι το $mat[1,3]$. Αντίστοιχα, μπορούμε να εξαγάγουμε τμήματα πινάκων χρησιμοποιώντας τις συντεταγμένες τους, με τον ίδιο τρόπο που το κάνουμε και για τα διανύσματα. Η βασική διαφορά εδώ είναι ότι ανάλογα με τις επιλογές μας μπορούμε να πάρουμε διανύσματα ή νέους πίνακες. Έτσι για παράδειγμα στον παρακάτω πίνακα:

```{r}
mat<-matrix(seq(1:20), nrow=4, ncol=5, byrow=T)
```

η εντολή:

```{r}
mat[1,3]
```

επιστρέφει ένα στοιχείο (την τιμή 3). 
Σημειώστε ωστόσο ότι η εντολή:

```{r}
mat[1,]
```

επιστρέφει ένα διάνυσμα που περιέχει όλες τις τιμές της πρώτης γραμμής. Η σύνταξη $Μ[i,]$ επιστρέφει το σύνολο των τιμών της γραμμής $i$ ενώ με αντίστοιχο τρόπο η $M[,j]$ επιστρέφει τις τιμές της στήλης $j$. Χρήση διανυσμάτων μέσα στις αγκύλες οδηγούν φυσιολογικά σε αποκομιδή τμημάτων του πίνακα που έχουν δομή πίνακα.

```{r}
mat[1:2,3:5]
```

### 3.3.2 Συναρτήσεις πινάκων

Οι περισσότερες συναρτήσεις που χρησιμοποιούμε για την ανάλυση δεδομένων σε πίνακες είναι οι ίδιες με αυτές που επενεργούν σε πλαίσια δεδομένων και γι' αυτό θα τις εξετάσουμε πιο αναλυτικά σε ξεχωριστό κεφάλαιο. 
Κάποιες βασικές συναρτήσεις πινάκων είναι αυτές που σχετίζονται με τη δομή και τις διαστάσεις τους. Παίρνουμε τις διαστάσεις ενός πίνακα με την $dim()$:

```{r}
dim(mat)
```

Συναφής με τις διαστάσεις των πινάκων είναι και η $dimnames()$ η οποία χρησιμοποιείται για να αποδοθούν ονόματα στις γραμμές και τις στήλες του πίνακα. Οι τιμές που παίρνει η $dimnames()$ είναι ιδιαίτερης κατηγορίας καθώς αποτελούνται από διανύσματα που δεν έχουν εξ' ορισμού το ίδιο μήκος. Μεταβλητές αυτής της κατηγορίας ονομάζονται λίστες lists και θα τις δούμε πιο αναλυτικά στη συνέχεια. Σχηματίζονται με τη συνάρτηση $list()$ που παίρνει σαν ορίσματα έναν αριθμό διανυσμάτων που θα πρέπει να είναι στην περίπτωσή μας 2 και με μήκη ίσα με τις διαστάσεις (γραμμών-στηλών) του πίνακα. Στο παρακάτω παράδειγμα αποδίδουμε στον πίνακα mat τις τιμές R1 έως R4 ως ονόματα γραμμών και τα γράμματα A-E ως ονόματα στηλών.

```{r}
dimnames(mat)<-list(c("R1","R2","R3","R4"), c("A","B","C","D","E"))
mat
```

H $dimnames()$ μπορεί να ενσωματωθεί σαν παράμετρος στην $matrix()$. H παρακάτω εντολή δημιουργεί απευθείας τον πίνακα και αποδίδει και τα ονόματα των γραμμών-στηλών:

```{r}
matrix(1:20, nrow=4, ncol=5, byrow=T, dimnames(mat)<-list(c("R1","R2","R3","R4"), c("A","B","C","D","E")))
```

Η τιτλοδότηση γραμμών και στηλών μπορεί να γίνει και σε δύο βήματα με τη χρήση των συναρτήσεων $rownames()$ και $colnames()$ οι οποίες δέχονται διανύσματα. Έτσι η εντολή:

```{r}
colnames(mat)<-c("C1", "C2", "C3", "C4", "C5")
mat
```
αλλάζει τα ονόματα των στηλών μόνο του $mat$.
  
Πέρα από την τιτλοδότηση, οι πίνακες μπορούν να αυξηθούν, να συνενωθούν ή να αλλάξουν διαστάσεις. Διανύσματα ή και πίνακες μπορούν να ενωθούν με πίνακες ανά γραμμή ή ανά στήλη με τις $rbind()$ και $cbind()$ αντίστοιχα. Στο παράδειγμα:

```{r}
mat1<-matrix(seq(1:10), nrow=2, ncol=5, byrow=T, dimnames=list(c("R1","R2"), c("C1","C2","C3","C4","C5")))
mat2<-matrix(seq(21:40), nrow=4, ncol=5, byrow=T, dimnames=list(c("L1","L2","L3","L4"), c("S1","S2","S3","S4","S5")))
rbind(mat1,mat2)
```

οι δύο πίνακες ενώνονται με την $rbind()$ και ο ένας μπαίνει πρακτικά κάτω από τον άλλον. Σημειώστε ότι ως τίτλοι στηλών παραμένουν αυτοί του πρώτου πίνακα στη σειρά ένωσης.

```{r}
rbind(mat2,mat1)
```

Mε απολύτως ανάλογο τρόπο δύο πίνακες μπορούν να ενωθούν δίπλα-δίπλα (σε επίπεδο στηλών) με την $cbind()$ μόνο εφόσον έχουν τον ίδιο αριθμό γραμμών. Με τον ίδιο τρόπο οι $rbind()$ και $cbind()$ ενώνουν πίνακες με διανύσματα που έχουν τις κατάλληλες διαστάσεις.

```{r}
x<-c(5,6,7,8)
cbind(mat2, x)
```

Αλλαγή τώρα στις διαστάσεις ενός πίνακα μπορεί να γίνει με τη διαδοχική μετατροπή του σε διάνυσμα και την αναδιαμόρφωσή του σε πίνακα. Είναι προφανές ότι χρειάζεται ιδιαίτερη προσοχή στις διαστάσεις σε πράξεις πινάκων καθώς αυτές μπορούν να εκτελεστούν μόνο εφόσον αυτές είναι συμβατές μεταξύ τους. Οι εντολές που ακολουθούν πραγματοποιούν τη μετατροπή του $mat2$ από 4Χ5 σε 2Χ10: 

```{r}
v<-as.vector(mat2)
matrix(v, nrow=2, ncol=10)
```

προσέξτε όμως πως η σειρά διάταξης των τιμών είναι τώρα διαφορετική καθώς η $as.vector()$ δημιουργεί ένα διάνυσμα διαβάζοντας τον πίνακα υποχρεωτικά ανα στήλη.
Η δημιουργία αντίστροφου πίνακα γίνεται εύκολα με την χρήση της συνάρτησης $t()$ (transpose).

```{r}
mat2
t(mat2)
```


## 3.4 Πλαίσια Δεδομένων

Τα πλαίσια δεδομένων (dataframes) είναι η πιο κοινή και πιο διαδεδομένη κατηγορία αντικειμένων στην R. Η ευελιξία τους και ο μικρός αριθμός περιορισμών που έχουν σε ό,τι αφορά την ενσωμάτωση διαφορετικών τύπων δεδομένων τα κάνουν εξαιρετικά εύχρηστα. Ένα μεγάλο εύρος συναρτήσεων επενεργούν πάνω σε πλαίσια δεδομένα και για το λόγο αυτό αφιερώνουμε εξ ολοκλήρου σε αυτά το επόμενο κεφάλαιο. Στο σημείο αυτό αρκεί να ορίσουμε τα πλαίσια δεδομένων ως πίνακες δύο διαστάσεων οι οποίοι ωστόσο δεν υπόκεινται στον περιορισμό των δεδομένων μίας μόνο κατηγορίας. Τα πλαίσια δεδομένων λοιπόν μπορούν να περιέχουν διαφορετικούς τύπους δεδομένων σε διαφορετικές στήλες, με την προϋπόθεση ότι το μήκος της κάθε στήλης είναι το ίδιο. Από αυτήν την άποψη μπορούμε να σκεφτούμε τα πλαίσια δεδομένων ως ένωση διανυσμάτων ίσου μήκους. Η δημιουργία τους μπορεί να γίνει με τη συνάρτηση $data.frame()$:

```{r}
legends<-data.frame(names=c("Kenny","Robbie","Steven"), numbers=c(7,9,8), years=c(1959, 1970, 1974))
legends
```

H $data.frame()$ δίνει έτσι ταυτόχρονα τους τίτλους των διανυσμάτων καθώς και τις τιμές τους. Η πρόσβαση στις τιμές ενός πλαισίου δεδομένων μπορεί να γίνει είτε μέσω των διαστάσεών του:

```{r}
legends[,2]
```

είτε μέσω των ονομάτων των επιμέρους διανυσμάτων του. Σε αυτήν την περίπτωση χρησιμοποιούμε τον τελεστή του δολλαρίου $ για να αναφερθούμε σε αυτά:

```{r}
legends$names
```


### 3.4.1 Εφαρμογή συναρτήσεων σε πίνακες και πλαίσια δεδομεων (apply)

Όπως είδαμε παραπάνω οι πίνακες (matrices) και τα πλασια δεδομένων (dataframes) είναι σύνολα διανυσμάτων ίσου μήκους. Στην περίπτωση που θέλουμε να εφαρμόσουμε μια συνάρτηση σε καθένα από τα συστατικά διανύσματα ενός πίνακα μπορούμε να το κάνουμε χωρίς να καλέσουμε μια επαναληπτική διαδικασία με τη χρήση μιας ειδικής συναρτήσης που ονομάζεται $apply()$. Η $apply()$ είναι ουσιαστικά μια "συνάρτηση συναρτήσεων" που καλεί άλλες συναρτήσεις πάνω σε πίνακες είτε ανα γραμμή, είτε ανα στήλη. Έστω για παράδειγμα ότι θέλουμε να βρούμε το άθροισμα των τιμών κάθε γραμμής ενός matrix. Μπορούμε να εφαρμόσουμε την αντίστοιχη συνάρτηση $sum()$ μέσω της $apply()$ απευθείας πάνω στον πίνακα. Στη συνέχεια βλέπουμε πώς.
Αρχικά θα δημιουργήσουμε έναν πίνακα 4χ5 τον οποίον θα γεμίσουμε με 20 τυχαίους αριθμούς μεταξύ 0 και 1 που επιλέγονται από μια ομοιόμορφη κατανομή. Τη συνάρτηση που κάνει αυτήν την μοντελοποίηση και που λέγεται $runif()$ θα την δούμε αναλυτικά σε επόμενο κεφάλαιο (Κεφάλαιο 7). Στη συνέχεια οι 20 αυτές τιμές οργανώνονται σε έναν πίνακα με την εντολή $matrix()$:

```{r}
values<-runif(20)
mat<-matrix(values, nrow=4, ncol=5, byrow=T, dimnames=list(c("L1","L2","L3","L4"), c("S1","S2","S3","S4","S5")))
mat
```

Μπορούμε τώρα να αθροισουμε τις τιμές του $mat$ σε μία εντολή ανά γραμμή με τη χρήση της $apply()$ και την εφαρμογή της συνάρτησης που υπολογίζει το άθροισμα ενός διανύσματος και που λέγεται $sum()$ ως εξής:

```{r}
apply(mat, 1, FUN=sum)
```

H κλήση της $apply()$ περιλαμβάνει τον πίνακα, την εφαρμοζόμενη συνάρτηση (εδώ είναι η $sum()$) και τη διάσταση που θα εφαρμοστεί, η οποία δίνεται ενδιάμεσα και είναι 1 για τις γραμμές και 2 για τις στήλες. Συγκρίνετε την παραπάνω κλήση με αυτήν:

```{r}
apply(mat, 2, FUN=sum)
```

Στην πρώτη περίπτωση η άθροιση έγινε ανα γραμμή (4 τιμές) ενώ στη δεύτερη ανά στήλη (5 τιμές). Για τη συγκεκριμένη διαδικασία η R εχει και ξεχωριστές συναρτήσεις που ονομάζονται $rowSums()$ και $colSums()$ αντίστοιχα, ωστόσο αξίζει να θυμόμαστε τη γενικότερη εφαρμογή συναρτήσεων μέσω των $apply()$ καθώς μας προσδίδει μεγάλη ευελιξία στην εφαρμογή οποιασδήποτε συνάρτησης διανυσμάτων.  

## 3.5 Πίνακες περισσότερων από δύο διαστάσεων

Η R υποστηρίζει τη δημιουργία πινάκων περισσότερων από δύο διαστάσεων, με την απλή χρήση της παραμέτρου $dim$. Η δημιουργία των πινάκων μπορεί να γίνει αρχικά σε κενό σύνολο το οποίο στη συνέχεια θα "γεμίσει" από δεδομένα. Σε κάθε περίπτωση όμως το αρχικό διάνυσμα που θα "μορφοποιηθεί" θα πρέπει να έχει τις ακριβείς διαστάσεις του πολυδιάστατου πίνακα. Στο παράδειγμα που ακολουθεί δημιουργούμε ένα τέτοιο διάνυσμα 36 στοιχείων και στη συνέχεια το οργανώνουμε σε έναν πίνακα 2χ6χ3: 

```{r}
x<-rep(0,36)
dim(x)<-c(2,6,3)
```

Προσέξτε πώς δημιουργήσαμε ένα διάνυσμα από 36 μηδενικά με τη συνάρτηση $rep(a,n)$, η οποία δημιουργεί μια επανάληψη του $a$ για $n$ στοιχεία. Στη συνέχεια με τη χρήση της $dim()$ οργανώσαμε το αρχικό διάνυσμα σε έναν πίνακα (array) τριών διαστάσεων.

```{r}
class(x)
```

Οι arrays οργανώνονται σε πολλές διαστάσεις με ιδιαίτερη σειρά που ακολουθεί τη λογική [γραμμή, στήλη, μπλόκ1, μπλοκ2..., κοκ]. Για να φανεί καλύτερα αυτό ας δώσουμε μια τιμή σε ένα στοιχείο του x:

```{r}
x[1,3,2]<-5
x
```

όπου φαίνεται ότι η τιμή 5 έχει αποδοθεί στο δεύτερο μπλοκ τιμών στη θέση [1,3] με βάση τη συνθήκη [γραμμή, στήλη]. Ο γενικός κανόνας που πρέπει να θυμόμαστε στους πολυδιάστατους πίνακες είναι ότι οι δύο πρώτες διαστάσεις αφορούν πάντα το συνδυασμό γραμμής-στήλης στο μπλοκ που μας ενδιαφέρει αλλά ο αριθμός αυτού του μπλοκ δίνεται από τις συντεταγμένες στην τρίτη θέση κι έπειτα. Αυτό μπορεί να φανεί καλύτερα αν αλλάξουμε την οργάνωση του αρχικού διανύσματος μήκους 36 σε έναν πίνακα τεσσάρων διαστάσεων:

```{r}
dim(x)<-c(3,2,2,3)
x
```
Προσέξτε πώς μετά από αυτήν την "αναδόμηση" του $x$ η τιμή 5 είναι πλέον στη θέση [2,2,1,2].
  
## 3.6 Λίστες

### 3.6.1 Δημιουργία Λιστών

Οι λίστες (lists) είναι η πιο πολύπλοκη κατηγορία δεδομένων στην R. Αποτελούνται από σύνολα διανυσμάτων που δεν είναι υποχρεωτικό να είναι του ίδιου τύπου αλλά ούτε και του ίδιου μήκους. Στην πιο διευρυμένη μορφή τους μπορούν να περιέχουν ακόμα και πίνακες ή και συναρτήσεις ως στοιχεία. Μια λίστα δημιουργείται με τη χρήση της ομώνυμης συνάρτησης, η οποία δέχεται μια παράθεση στοιχείων, όπως στο παράδειγμα:

```{r}
l<-list(c(1,3,5), c("Steven", "Robbie", "Kenny", "Ian"), TRUE, c(0.9, 0.8))
l
```

Βλέπουμε ότι η λίστα απαρτίζεται από τις παραμέτρους που περάσαμε στην $list()$ με τη σειρά που το κάναμε. Για να δημιουργήσουμε μια πιο καλά οργανωμένη εκδοχή της θα δώσουμε ονόματα στα στοιχεία της $l$ με τη χρήση της $names$:

```{r}
names(l)<-c("odds", "names", "logical", "decimals")
l
```

Προσέξτε ότι τώρα τα ονόματα των στοιχείων της λίστας βρίσκονται στη θέση που προηγουμένων υπήρχε αρίθμηση σε διπλές αγκύλες. Ίσως το πιο σημαντικό σημείο σε ό,τι αφορά τις λίστες είναι η χρήση αυτών των διπλών αγκυλών. Είτε φέρουν ονόματα, είτε όχι, η θέση των στοιχείων μιας λίστας δίνεται από έναν αριθμό μέσα σε διπλές αγκύλες αντί για μονές όπως ισχύει για τα διανύσματα και τους πίνακες. Η διαφορά στη χρήση μονών και διπλών αγκυλών είναι αρκετά λεπτή και μπορεί να διαφύγει σε πρώτο επίπεδο. Προσέξτε τη διαφορά μεταξύ:

```{r}
l[1]
```

και:

```{r}
l[[1]]
```

Πρακτικά δε φαίνεται να υπάρχει καμία. Δείτε όμως τι είδους αντικείμενο κρύβεται πίσω από τις δύο αυτές δομές:

```{r}
class(l[1])
class(l[[1]])
```

Χρήση δηλαδή των μονών αγκυλών επιστρέφει ένα αντικείμενο τύπου λίστας ενώ οι διπλές αγκύλες επιστρέφουν το διάνυσμα του πρώτου στοιχείου. Αυτό είναι πολύ σημαντικό καθώς όπως έχουμε συζητήσει και παραπάνω συγκεκριμένες συναρτήσεις μπορούν να εφαρμοστούν μόνο σε συγκεκριμένους τύπους αντικειμένων. Πώς μπορούμε τώρα να εντοπίσουμε ένα στοιχείο εντός των διανυσμάτων που απαρτίζουν μια λίστα; Ακολουθώντας τη λογική που έχουμε δει ως τώρα, αρκεί να προσδιορίσουμε αρχικά το διάνυσμα που θέλουμε με διπλές αγκύλες και στη συνέχεια να ορίσουμε σε αυτό την επιθυμητή θέση με μονές. Έτσι π.χ. το τρίτο όνομα στο στοιχείο $names$ της $l$ δίνεται ως εξής:

```{r}
l[[2]][3]
```

Εναλλακτικά, η πρόσβαση σε αυτό μπορεί να γίνει και με τη χρήση του ονόματος του διανύσματος όπως είδαμε στα dataframes:
```{r}
l$names[3]
```

Στην περίπτωση που θέλουμε να πάρουμε πίσω όλη τη λίστα σε ένα διάνυσμα μπορούμε να την "καταρρεύσουμε" σε διάνυσμα με την συνάρτηση $unlist()$:
```{r}
unlist(l)
```

Όπως φαίνεται, στην περίπτωση ονοματισμένης λίστας, τα ονόματα διατηρούνται και στο διάνυσμα, κάτι που είναι αρκετά βολικό.

### 3.6.2 Χειρισμός Λιστών με συναρτήσεις τύπου apply()

Οι χειρισμοί των λιστών μοιάζουν πολύ με τους αντίστοιχους των διανυσμάτων. Έτσι μπορούμε να ενώσουμε δύο ή περισσότερες λίστες με την συνάρτηση $c()$:

```{r}
l1<-list(c("A","B"), c(1,2,3))
l2<-list(c("C","D","E"), c(T,F,F,F))
l3<-c(l1,l2)
l3
```

Η βασικότερη χρησιμότητα των λιστών είναι η δυνατότητα εφαρμογής συναρτήσεων στα στοιχεία τους με τη χρήση των συναρτήσεων $apply()$. Όπως είδαμε και στο παράδειγμα των πινάκων/πλαισίων δεδομένων οι συναρτήσεις τύπου $apply()$ λειτουργούν καλώντας άλλες συναρτήσεις και εφαρμόζοντάς τις απευθείας, με αποτέλεσμα την ταχύτατη εκτέλεσή τους. Απαραίτητη προϋπόθεση είναι τα στοιχεία της λίστας να μπορούν να αποτελέσουν όρισμα της συνάρτησης. Στην περίπτωση των λιστών, το πλεονέκτημα που έχουμε σε σχέση με τους πίνακες είναι ότι τα διανύσματα που μπορούμε να αναλύσουμε δεν είναι υποχρεωτικά ίδιου μήκους. Έστω για παράδειγμα ότι έχουμε μια σειρά από διανύσματα των οποίων θέλουμε να υπολογίσουμε τις μέγιστες τιμές. Μπορούμε να αποφύγουμε μια επαναληπτική κλήση της αντίστοιχης συνάρτησης $max()$ ενσωματώνοντας τα διανύσματα σε μια λίστα και καλώντας την $max()$ σε μία κλήση της $sapply()$:

```{r}
x<-c(1, 8, 9, 12, 5)
y<-c(6, 7, 0.8, 2, 5.1)
z<-c(-10, 5, 2, 3.8)
my_list<-list(x,y,z)
sapply(my_list, FUN=max)
```

Το αποτέλεσμα είναι ένα διάνυσμα τριών τιμών που αντιστοιχεί στις μέγιστες τιμές των $x$, $y$ και $z$. Το ίδιο αποτέλεσμα καταχωρημένο σε λίστα προκύπτει αν αντί για την $sapply()$ καλέσουμε την $lapply()$:

```{r}
lapply(my_list, FUN=max)
```

Εκτός από τις $apply()$, $sapply()$ και $lapply()$ που είδαμε εδώ υπάρχουν και άλλες συναρτήσεις σε αυτήν την κατηγορία, τις οποίες θα δούμε αναλυτικότερα σε πιο πολύπλοκες εφαρμογές συναρτήσεων.

## Συμπεράσματα
Ολοκληρώνοντας αυτό το κεφάλαιο είμαστε πλέον σε θέση να διακρίνουμε μεταξύ διαφορετικών τύπων και δομών δεδομένων αλλά και να εκτελέσουμε υπολογισμούς σε αυτά με την εφαρμογή συναρτήσεων. Καθώς εξοικειωνόμαστε με τη σύνταξη των τελευταίων αλλά και τη δομή των πρώτων μπορούμε να αρχίσουμε να εξετάζουμε παραδείγματα αναλύσεων σε πραγματικά δεδομένα. Πριν από αυτό, θα εξετάσουμε στο επόμενο κεφάλαιο τον πιο κοινό τύπο δεδομένων που είναι τα πλαίσια δεδομένων (data.frames) και θα δούμε πώς μπορούμε να οργανώσουμε τα δικά μας δεδομένα σε τέτοιες δομές.

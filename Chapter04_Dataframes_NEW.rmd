---
title: "Κεφάλαιο 4. Πλαίσια Δεδομένων, Παράγοντες και Χειρισμοί Συνόλων"
author: "Χριστόφορος Νικολάου"
date: '`r Sys.Date()`'
output:
  html_document:
    code_folding: show
    fig_caption: yes
    toc: yes
    toc_depth: 3
    toc_float: yes
  word_document: null
  pdf_document:
    latex_engine: xelatex
link-citations: yes
header-includes:
- \usepackage[greek]{babel}
- \usepackage{fontspec}
- \usepackage{xunicode}
- \usepackage{xgreek}
- \usepackage{polyglossia}
- \setmainlanguage{greek}
- \setmainfont[Ligatures=TeX]{Linux Libertine O}
- \newfontfamily\greekfonttt[Script=Greek]{Linux Libertine O}
bibliography: null
---


## Εισαγωγή
Μεταξύ των τύπων δεδομένων που είδαμε στο προηγούμενο κεφάλαιο, τα πλαίσια δεδομένων αποτελούν τον πιο εύχρηστο και τον πιο ευρέως χρησιμοποιούμενο.
Ένα πλαίσιο δεδομένων είναι ένας πίνακας δύο διαστάσεων, στον οποίο κάθε στήλη περιέχει τις τιμές μιας συγκεκριμένης μεταβλητής και κάθε σειρά αντιστοιχεί σε ένα στοιχείο για το οποίο έχουν μετρηθεί οι μεταβλητές. Η βασική διαφορά του από τα matrices είναι ότι οι τιμές δεν είναι υποχρεωτικό να είναι αριθμητικές αλλά μπορούν να είναι και σειρές χαρακτήρων.
Οι βασικές προϋποθέσεις για τη δημιουργία ενός πλαισίου δεδομένων είναι:
1. Κάθε στήλη πρέπει να περιέχει τον ίδιο αριθμό στοιχείων δεδομένων.
2. Τα ονόματα των στηλών δεν μπορούν να είναι κενά. Ακόμα κι αν οι στήλες δεν έχουν όνομα, η R θα τους αποδώσει αυτόματα ένα που θα προκύπτει από τον αύξοντα αριθμό τους μετά το πρόθεμα V (Value), π.χ. \$V1, \$V2, κ.ο.κ.
3. Τα ονόματα των γραμμών δεν είναι υποχρεωτικά αλλά αν υπάρχουν θα πρέπει να είναι μοναδικά.
4. Τα δεδομένα που είναι αποθηκευμένα σε ένα πλαίσιο δεδομένων μπορούν να έχουν αριθμητική τιμή ή τιμή χαρακτήρα, ωστόσο θα πρέπει κάθε στήλη να περιέχει αποκλειστικά δεδομένα ενός είδους. Στην αντίθετη περίπτωση η R θα μετατρέψει τα δεδομένα σε ένα είδος τιμών μέσω εξαναγκασμού (coersion, βλ. Κεφάλαιο 3). 

## 4.1 Χειρισμοί Πλαίσιων Δεδομένων

Στο προηγούμενο κεφάλαιο είδαμε πώς δημιουργούμε πλαίσια δεδομένων (στο εξής data.frames) με την ομώνυμη συνάρτηση ($data.frame()$), ωστόσο τις περισσότερες φορές τα πλαίσια δεδομένων θα δημιουργούνται ως αντικείμενα απευθείας με ανάγνωση δεδομένων μέσω συναρτήσεων της ομάδας $read()$ (βλ. Κεφάλαιο 2). Στο Κεφάλαιο αυτό θα επικεντρωθούμε στους χειρισμούς των dataframes και στις βασικές αναλύσεις που μπορούμε να κάνουμε πάνω σε αυτά.
Ας θυμηθούμε καταρχάς τη δομή ενός dataframe φορτώνοντας απευθείας από την R ένα σετ δεδομένων που περιέχει μετεωρολογικές μετρήσεις (airquality): 

```{r, eval=T, echo=T}
str(airquality)
```

Από τη δομή του dataframe βλέπουμε ότι πρόκειται για ένα σετ 153 παρατηρήσεων για 6 μεταβλητές που στην προκειμένη περίπτωση είναι όλες αριθμητικές (ακέραιες ή κινητής υποδιαστολής). Η δομή του dataframe επίσης μας επιτρέπει να δούμε τα ονόματα των μεταβλητών που φαίνονται στο αριστερό μέρος και είναι στην ουσία τα ονόματα των στηλών.
Όπως έχουμε δει σε προηγούμενο κεφάλαιο καθεμιά από τις μεταβλητές είναι ένα διάνυσμα το οποίο μπορούμε να καλέσουμε με το όνομά του με τον τελεστή του $:

```{r, eval=T, echo=T}
airquality$Ozone
```

### 4.1.1 Κενές τιμές (missing values)

Κοιτώντας καλύτερα το παραπάνω διάνυσμα θα παρατηρήσετε ότι κάποιες από τα στοιχεία του δεν αντιστοιχούν σε αριθμητικές τιμές αλλά στο σύμβολο ΝΑ που στην R αντιστοιχεί στο αρκτικόλεξο "Νon-assigned". Η τιμή ΝΑ είναι ο τρόπος με τον οποίο η R αποδίδει τις τιμές που λείπουν από ένα σύνολο δεδομένων, έτσι ώστε να διατηρείται η δομή των πινάκων και των διανυσμάτων ακόμα κι αν στη θέση κάποιων στοιχείων δεν έχει αποδοθεί τιμή. Η ύπαρξη της ΝΑ είναι πολύ χρήσιμη για τη δομή των αντικειμένων, ωστόσο μπορεί να δημιουργήσει προβλήματα στην εφαρμογή ακόμα και απλών συναρτήσεων. Για παράδειγμα, αν προσπαθήσουμε να υπολογίσουμε τo άθροισα τιμών του διανύσματος Ozone με τη συνάρτηση $sum()$ προκύπτει το παρακάτω πρόβλημα:

```{r, eval=T, echo=T}
sum(airquality$Ozone)
```

Βλέπουμε δηλαδή ότι η ύπαρξη κενών τιμών στο διάνυσμα δεν επιτρέπει την εξαγωγή του αθροίσματος. Υπάρχουν διάφοροι τρόποι για να αντιμετωπίσει κανείς αυτό το πρόβλημα. Πολλές συναρτήσεις έχουν ενσωματωμένες παραμέτρους που τους επιτρέπουν να αγνοήσουν τις κενές τιμές. Για παράδειγμα η $sum()$ (αλλά και άλλες) μπορεί να εκτελεστεί ως εξής:

```{r, eval=T, echo=T}
sum(airquality$Ozone, na.rm=T)
```

Εδώ η παράμετρος na.rm=T επιβάλλει την εκτέλεση της συνάρτησης μόνο σε πλήρεις τιμές. 
Ωστόσο τέτοιες επιλογές δεν υπάρχουν σε όλες τις συναρτήσεις κι έτσι είναι καλό να έχουμε έλεγχο των δεδομένων σχετικά με τις κενές τιμές. Ένας εύκολος τρόπος να δούμε ποιες τιμές σε ένα διάνυσμα είναι κενές είναι η συνάρτηση $is.na()$

```{r, eval=T, echo=T}
is.na(airquality$Ozone)
```

η οποία επιστρέφει μια λογική τιμή ανάλογα με την ύπαρξη ή όχι κενής τιμής σε κάθε θεση του διανύσματος. Μπορεί κανείς εύκολα να ενσωματώσει αυτή τη λογική σε διανυσματική εφαρμογή όπως είδαμε στο προηγούμενο κεφάλαιο, όπως στο παράδειγμα:

```{r, eval=T, echo=T}
sapply(airquality$Ozone, is.na)
```

Σε επόμενη ενότητα θα δούμε πώς μπορεί κανείς να δημιουργήσει υποσύνολα των τιμών με βάση την ύπαρξη ή όχι τιμής αλλά και πιο πολύπλοκους αριθμητικούς και λόγικους ελέγχους. 

### 4.1.2 Συναρτήσεις Ελέγχου Τιμών

Εκτός από τον έλεγχο ύπαρξης τιμής που είδαμε παραπάνω, μια σειρά από συναρτήσεις ελέγχου τιμών μπορούν να χρησιμοποιηθούν με απολύτως αντίστοιχο τρόπο. Οι συναρτήσεις τύπου $is.()$ είναι πολλές, όμως κάποιες από τις σημαντικότερες φαίνονται στον παρακάτω πίνακα.

```{r, echo=F, eval=T}
data<-data.frame(Συνάρτηση=c("is.na","is.infinite", "is.nan","is.integer","is.character","is.numeric","is.factor", "is.element"),Έλεγχος=c("Ύπαρξη τιμής","Προσδιορισμένη τιμή", "Τιμή που απειρίζεται", "Η τιμή είναι ακέραιος","Η τιμή είναι χαρακτήρας","Η τιμή είναι αριθμητικό", "Η τιμή είναι παράγοντας", "Σύγκριση συνόλων"))
knitr::kable(data, caption = "Πίνακας 4.1: Βασικές συναρτήσεις ελέγχου τιμών")
```

Πιο αναλυτικά οι συναρτήσεις αυτές πραγματοποιούν τους εξής ελέγχους:  

1. $is.na()$: όπως είδαμε παραπάνω ελέγχει την ύπαρξη τιμής   

2. $is.finite()$, $is.nan()$: ελέγχουν κατά πόσο σε ένα διάνυσμα μια τιμή έχει αποδοθεί ως άπειρο, πραγματικός αριθμός ή αλφαριθμητικό. Είναι πολύ χρήσιμη για τον έλεγχο ύπαρξης πραγματικών αριθμών ή απροσδιοριστίας σε αριθμητικές πράξεις όπως π.χ. διαιρέσεις με το 0, υπολογισμό λογαρίθμων αρνητικών τιμών, πράξεων μεταξύ τους κλπ. Είναι σημαντικό εδώ να διακρίνουμε μεταξύ των περιπτώσεων που η R αποδίδει τιμή απείρου σε κάποιες πράξεις και πώς ορίζει την απροσδιοριστία. Η R ερμηνεύει πράξεις όπως η διαίρεση με το 0 με βάση τα όρια ακρίβειας κι έτσι η πράξη 1/0 αποδίδει ως αποτέλεσμα το όριο της παράστασης για παρονομαστή που τείνει στο 0, άρα άπειρο:

```{r}
x<-5
y<-1/(x-5)
y
is.infinite(y)
```

ένα άλλο παράδειγμα είναι o λογάριθμος:

```{r}
z<-log(0)
z
is.infinite(z)
```

όπου παρόλο που η τιμή τείνει στο -Ιnf η $is.inf()$ επιστρέφει και πάλι την τιμή TRUE, λειτουργεί δηλαδή ανεξάρτητα από το πρόσημο.
Πότε όμως προκύπτουν απροσδιοριστίες; Χαρακτηριστικότερες περιπτώσεις είναι οι πράξεις μεταξύ τιμών απείρου ή η εφαρμογή τιμών εκτός πεδίου ορισμού συναρτήσεων. 

```{r}
x<-seq(-10,10,1) # σειρά αριθμών -10..10
z<-sqrt(x) # εφαρμογή τετραγωνικής ρίζας
z
is.nan(z) 
is.nan(log(0)+1/0) # πράξη μεταξύ τιμών απείρου
```

Όπως φαίνεται στο πρώτο παράδειγμα, για εφαρμογή τιμών εκτός πεδίου ορισμού συνάρτησης η R επιστρέφει προειδοποίησεις για τη δημιουργία απροσδιόριστων τιμών που καταγράφονται ως NaN (not a number). Η $is.nan()$ ελέγχει την ύπαρξη τους.  

3. $is.numeric()$, $is.integer()$, $is.character()$: είναι συναρτήσεις που ελέγχουν τον τύπο της μεταβλητής που εξετάζεται. Όπως έχουμε συζητήσει και αλλού, στα dataframes όλα τα διανύσματα είναι υποχρεωτικά του ίδιου τύπου λόγω του "εξαναγκασμού" που εφαρμόζει. Ωστόσο όλες οι παραπάνω συναρτήσεις είναι χρήσιμες στις περιπτώσεις που είτε δεν γνωρίζουμε το είδος της μεταβλητής, είτε υπάρχει πλήθος διαφορετικών τύπων μεταβλητών στο ίδιο αντικείμενο.

```{r, echo=T}
str(iris)
is.integer(iris$Sepal.Length)
is.numeric(iris$Sepal.Length)
```
  
4. $is.factor()$: Η συνάρτηση $is.factor()$ ελέγχει μια ειδική κατηγορία δεδομένων που ονομάζονται παράγοντες (factors). Οι παράγοντες είναι κατηγορικές μεταβλητές που η R χρησιμοποιεί για να οργανώσει πιο πολύπλοκα αντικείμενα. Οι παράγοντες είναι στην ουσία διανύσματα χαρακτήρων που όμως μεταφράζονται πάντα σε κατηγορικά δεδομένα όταν χειριζόμαστε πλαίσια δεδομένων. Στο παρακάτω παράδειγμα βλέπουμε τη λειτουργία των παραγόντων στο ενσωματωμένο στην R πλαίσιο δεδομένων iris:

```{r, echo=T}
str(iris)
is.factor(iris$Species)
```

Στην τελευταία γραμμή του output της $str()$ βλέπουμε ότι το διάνυσμα Species που περιέχει τα ονόματα των ειδών ίριδος αναγνωρίζεται ως factor με 3 επίπεδα (levels) τα οποία αντιστοιχούν στις τρείς διαφορετικές τιμές που παίρνει το διάνυσμα Species. Επί της ουσίας όλα τα διανύσματα που είναι factors είναι διανύσματα χαρακτήρων ωστόσο εφόσον χαρακτηριστούν ως factors η συνάρτηση $is.character()$ δεν επαληθεύεται:

```{r}
is.character(iris$Species)
```

Για ποιο λόγο η R μετατρέπει τα διανύσματα χαρακτήρων σε factors; Αυτό συμβαίνει επειδή οι παράγοντες είναι ιδιαίτερα χρήσιμοι για μια σειρά από χειρισμούς σε πλαίσια δεδομένων. Για το λόγο αυτό θα συζητήσουμε για αυτούς αναλυτικά σε επόμενη ενότητα.   

5. $is.element()$: η συγκεκριμένη συνάρτηση χρησιμοποιείται για να συγκρίνει διανύσματα σε ό,τι αφορά την παρουσία κοινών στοιχείων. Εκτελεί έτσι μια συγκριση συνόλων. Στην πιο απλή της μορφή απλά ελέγχει την ύπαρξη ενός στοιχείου σε ένα διάνυσμα:

```{r, echo=T}
name<-"Steven"
legends<-c("Kenny", "Ian", "Billie", "Steven", "Robbie")
is.element(name, legends)
```

Στην πιο σύνθετη μορφή της συγκρίνει δύο διανύσματα στη βάση του δεύτερου, επιστρέφει δηλαδή ένα διάνυσμα μήκους ίσου με το μήκος του διανύσματος που τοποθετείται πρώτο στο όρισμα της $is.element(a, b)$. Η σύγκριση επιστρέφει μια σειρά λογικών τιμών που είναι το αποτέλεσμα ελέγχου ύπαρξης των στοιχείων του διανύσματος $a$ στο $b$. Για παράδειγμα:

```{r, echo=T}
forwards<-c("Ian", "Robbie","Michael")
legends<-c("Kenny", "Ian", "Billie", "Steven", "Robbie")
is.element(forwards,legends)
```

H R διαθέτει μια σειρά από συναρτήσεις για πράξεις σε σύνολα που περιλαμβάνουν τόσο την κοινή ύπαρξη, την τομή, την ένωση κλπ. Σε επόμενη ενότητα θα δούμε πώς μπορούμε να δημιουργήσουμε υποσύνολα πριν τα συγκρίνουμε καθώς και πώς μπορούμε να συνδυάσουμε τα υποσύνολα με τους παράγοντες. 

## 4.2 Παραγοντές (factors)

Όπως είδαμε και στην αμέσως προηγούμενη ενότητα οι παράγοντες είναι στοιχεία των dataframes που αντιστοιχούν σε κατηγορικές μεταβλητές. Παρά το γεγονός ότι η R θα αποδώσει την ιδιότητα παράγοντα σε κάθε διάνυσμα χαρακτήρων μέσα σε ένα dataframe, αυτό έχει νόημα μόνο στην περίπτωση που ο αριθμός των μοναδικών τιμών μέσα στο διάνυσμα είναι περιορισμένος ώστε να επιτρέπει την ομαδοποίηση. Το πλήθος των μοναδικών τιμών μπορεί κανείς να δει με τη χρήση της συνάρτησης $levels()$ η οποία τις επιστρέφει σε ένα διάνυσμα χαρακτήρων: 

```{r, echo=T}
levels(iris$Species)
```

Στην πράξη οποιοδήποτε διάνυσμα χαρακτήρων μπορεί να μετατραπεί σε παράγοντα με τη χρήση της συνάρτησης $factor()$:
```{r, echo=T}
a_vector<-c(rep("X",5),rep("Y",3), rep("Z",1))
a_factor<-factor(a_vector)
levels(a_factor)
```

Στη συνέχεια θα δούμε πώς χειριζόμαστε αρχικά τα επιπέδα κι έπειτα τους ίδιους τους παράγοντες.

### 4.2.1 Δημιουργία και χειρισμός επιπέδων (levels) σε παράγοντες

Όταν παίρνουμε τα επίπεδα ενός παράγοντα, αυτά οργανώνονται πάντοτε με αλφαβητική σειρά. Στο παράδειγμα που ακολουθεί δημιουργούμε ένα πλαίσιο δεδομένων με τρία διανύσματα (εισόδημα, ηλικία και επίπεδο εκπαίδευσης), από τα οποία τα δύο πρώτα είναι αριθμητικές τιμές και το τελευταίο κατηγορική μεταβλητή που μετατρέπεται αυτόματα σε παράγοντα κατά τη δημιουργία του dataframe. 

```{r, echo=T}
# Data in vectors
income <- c(32,51,12,23,26,27,24,26,25,18,30,22,24,21,25,27,18)
age <- c(48,59,26,23,37,32,20,25,45,55,44,42,51,30,35,29,19)
education <- c("middle","high","basic","high","high","middle","high","high","middle","basic", "high", "basic", "basic", "middle", "middle", "middle", "basic")
# Create the dataframe.
income_data <- data.frame(income,age,education)
levels(income_data$education)
```

Σε αρκετές περιπτώσεις θέλουμε μια διαφορετική σειρά στα επίπεδα του παράγοντα. Αυτό γίνεται με την αντικατάσταση του παράγοντα από έναν παράγοντα όπου τα επίπεδα ορίζονται αναλυτικά όπως στο παράδειγμα:

```{r, echo=T}
income_data$education<-factor(income_data$education, levels=c("basic", "middle", "high"))
levels(income_data$education)
```


### 4.2.2 Χρήση Παραγόντων σε Πλαίσια Δεδομένων

Η βασική χρησιμότητα των παραγόντων είναι η κατηγοριοποίηση των δεδομένων σε ένα dataframe. Η R αναγνωρίζει τις μεταβλητές που μπορούν να χρησιμοποιηθούν ως παράγοντες και μπορεί να κατατάξει τις υπόλοιπες μεταβλητές με βάση τα επίπεδά τους πριν κάνει υπολογισμούς σε διανυσματικό επίπεδο. Χαρακτηριστικές συναρτήσεις που επιτρέπουν υπολογισμούς αυτού του είδους είναι η $by()$ και η $aggregate()$. Ας δούμε πώς μπορούμε να εκμεταλλευτούμε τους παράγοντες με αυτές στο παράδειγμα του income_data που δημιουργήσαμε προηγουμένως:

```{r, echo=T}
by(income_data$income, income_data$education, mean)
```

Στο πρώτο παράδειγμα η $by(a,b,c)$ ορίζει αρχικά το διάνυσμα στο οποίο θέλει να πραγματοποιήσει τον υπολογισμό, στη δεύτερη θέση το διάνυσμα παραγόντων με το οποίο θα κάνει την κατηγοριοποίηση και στην τρίτη θέση τη συνάρτηση που θα εφαρμοστεί για τους υπολογισμούς. Το αποτέλεσμα εδώ είναι η μέση τιμή του εισοδήματος ανά μορφωτικό επίπεδο. Αντίστοιχη λειτουργία πραγματοποιεί η $aggregate()$ με τη βασική διαφορά ότι τα διανύσματα παραγόντων που θα χρησιμοποιηθούν δίνονται με τη μορφή λίστας. Στο παρακάτω παράδειγμα υπολογίζουμε τη μέση τιμή των ηλικιών ανά μορφωτικό επίπεδο:

```{r, echo=T}
aggregate(income_data$age, by=list(Education=education), mean)
```

Ένα σημαντικό πλεονέκτημα της $aggregate()$ είναι ότι μπορεί να εφαρμοστεί σε συνδυασμούς παραγόντων που οδηγούν σε πιο πολύπλοκες κατηγοριοποιήσεις. Η R επιτρέπει την κατηγοριοποίηση μέσω πολλαπλών παραγόντων με τη χρήση της συνάρτησης $table()$. Η συγκεκριμένη συνάρτηση δέχεται ως είσοδο δύο ή περισσότερα διανύσματα παραγόντων και δημιουργεί έναν πίνακα "σύμπτωσης" (contingency table) που περιέχει τον αριθμό των στοιχείων των συνδυασμών τους. Μπορούμε να καταλάβουμε τη λειτουργία της εξαιρετικά χρήσιμης αυτής συνάρτησης με ένα παράδειγμα δύο διανυσμάτων παραγόντων. Με τις παρακάτω εντολές θα δημιουργήσουμε αρχικά ένα νέο διάνυσμα factor και στη συνέχεια θα το προσθέσουμε στο dataframe $income_data$ με την ομώνυμη συνάρτηση $data.frame()$:

```{r, echo=T}
ageclass<-c("higher","higher","lower","lower","higher","lower","lower", "lower","higher","higher","higher","higher","higher","lower","higher","lower",  "lower") 
income_data<-data.frame(income_data, AgeClass=ageclass)
str(income_data)
```

Το dataframe περιέχει τώρα δύο διανύσματα παραγόντων τα $education$ και $AgeClass$. Η $table()$ μας βοηθάει να απαντήσουμε σε ερωτήματα του τύπου "πόσοι συνδυασμοί ηλικακών ομάδων και μορφωτικών επιπέδων υπάρχουν;" ή "πόσα άτομα ανήκουν στο υψηλότερο μορφωτικό επίπεδο ενώ είναι νέοι;". Η εφαρμογή της γίνεται πάνω στο σύνολο των διανυσμάτων ενδιαφέροντος:

```{r, echo=T}
table(income_data$education, income_data$AgeClass)
```

ο 3Χ2 πίνακας που προκύπτει περιέχει όλην την πληροφορία σχετικά με την κατανομή των στοιχείων του dataframe μεταξύ των δύο κατηγορικών μεταβλητών. Στη συνέχεια βλέπουμε πώς μπορούμε να χρησιμοποιήσουμε την $aggregate()$ για να υπολογίσουμε χαρακτηριστικές τιμές για αυτούς τους συνδυασμούς, κάτι που δεν μπορούμε να κάνουμε με την $by()$.

```{r, echo=T}
aggregate(income_data$income, by=list(Education=education, Age=ageclass), mean)
```

Από το οποίο προκύπτει ότι υψηλότερο μέσο εισόδημα έχουν τα μεγαλύτερης ηλικίας και μορφωτικού επιπέδου άτομα. 
Στο επόμενο Κεφάλαιο θα δούμε πώς μπορούμε να χρησιμοποιήσουμε τους παράγοντες για να δημιουργήσουμε πληροφοριακά πλούσιες γραφικές παραστάσεις. Πριν από αυτό όμως, στην αμέσως επόμενη ενότητα, θα επικεντρωθούμε στην δημιουργία υποσυνόλων δεδομένων μέσω διαδικασιών που είναι ανεξάρτητες από παράγοντες και σε πράξεις μεταξύ τους. 

## 4.3 Δημιουργία Υποσυνόλων (subsetting)

Μία από τις πιο σημαντικές λειτουργίες στα πλαίσια δεδομένων είναι η κατηγοριοποίησή τους σε επιμέρους υποσύνολα. Στην προηγούμενη ενότητα είδαμε πώς μπορούμε να βοηθηθούμε σε κάτι τέτοιο από τους παράγοντες, ωστόσο συχνά θα χρειαστούμε να προχωρήσουμε σε δημιουργία υποσυνόλων με βάση αριθμητικά δεδομένα, πλήθη τιμών κλπ. Ας επιστρέψουμε στο παράδειγμα του dataframe που δημιουργήσαμε παραπάνω και ας δούμε αρχικά, με τη χρήση της συνάρτησης $summary()$ κάποια βασικά στατιστικά χαρακτηριστικά των δεδομένων που περιέχει:

```{r, echo=T}
summary(income_data)
```

Όπως βλέπουμε η $summary()$ επιστρέφει τις τιμές των κύριων τάσεων και ποσοστημορίων για κάθε αριθμητικό διάνυσμα, ενώ για τους παράγοντες επιστρέφει τις συχνότητες των στοιχείων ανάλογα με τα επίπεδα τους. Από την παρατήρηση των χαρακτηριστικών τιμών για την ηλικία βλέπουμε ότι η διάμεση τιμή (median) εναι ίση με 35, ενώ γνωρίζουμε ότι πέρα από την αριθμητική αποτύπωση της ηλικίας υπάρχει και μια κατηγορική ομαδοποίηση σε δύο επίπεδα του παράγοντα AgeClass. Αν θέλουμε να δούμε με βάση ποια αριθμητική τιμή έχει γίνει ο διαχωρισμός σε AgeClass: higher,lower μπορούμε να εφαρμόσουμε τη συνάρτηση εύρους στον συγκεκριμένο παράγοντα με την $by()$:

```{r, echo=T}
by(income_data$age, income_data$AgeClass, range)
```

από τα παραπάνω προκύπτει ότι οι ηλικιακές ομάδες έχουν κατηγοριοποιηθεί γύρω από τη διάμεση τιμή με τιμές >=median(age) να χαρακτηρίζονται ως "higher". 


### 4.3.1 Δημιουργία υποσυνόλων με απλούς ελέγχους

Πώς θα πρέπει να προχωρήσει κανείς όμως αν επιθυμεί μια διαφορετική ομαδοποίηση, π.χ. σε τρεις ηλιακές ομάδες ή με διαφορετικά όρια; Έστω π.χ. ότι μας ενδιαφέρει η σύγκριση εισοδημάτων μεταξύ των άνω και κάτω των 30. Σε αυτήν την περίπτωση θα πρέπει να δημιουργήσουμε νέα υποσύνολα με βάση αυτό το αριθμητικό όριο. Χωρίς να κάνουμε χρήση των παραγόντων μπορούμε να εφαρμόσουμε απευθείας έναν λογικό, αριθμητικό έλεγχο στο διάνυσμα που μας ενδιαφέρει. 

```{r, echo=T}
income_data$age<=30
```

Όπως έχουμε δει στο Κεφάλαιο 2 ο έλεγχος επιστρέφει ένα διάνυσμα λογικών τιμών. Πώς μπορούμε να χρησιμοποιήσουμε το διάνυσμα αυτό για να αποκομίσουμε τις τιμές; Αρκεί να το τοποθετήσουμε ως δείκτη πάνω στο ίδιο διάνυσμα: 

```{r, echo=T}
income_data$age<=30->x
income_data$age[x]
```

Η παραπάνω διαδικασία μπορεί να συμπτυχθεί σε μια γραμμή ενσωματώνοντας τον έλεγχο μέσα στον δείκτη:

```{r, echo=T}
income_data$age[income_data$age<=30]
```

### 4.3.2 Υποσύνολα με συνδυασμούς ελέγχων 

Η παραπάνω διαδικασία μπορεί να γίνει όσο πολύπλοκη επιθυμούμε με την ενσωμάτωση λογικών πράξεων πάνω στους ελέγχους. Οι λογικές πράξεις βασίζονται στους τελεστές άλγεβρας Boole που φαίνονται στον πίνακα 4.2 ο οποίος είναι μια επέκταση του Πίνακα 2.2.

```{r, echo=F, eval=T}
data<-data.frame(Τελεστής=c("==","!=", ">","<",">=","<=","&", "|", "!"),Πράξη=c("Έλεγχος Ισότητας","Έλεγχος Διαφοράς", "Μεγαλύτερο από", "Μικρότερο από","Μεγαλύτερο ή ίσο","Μικρότερο ή ίσο", "Σύνδεση ενδεχομένων (ΚΑΙ)", "Σύνδεση ενδεχομένων (Ή)", "Συμπλήρωμα ενδεχομένου (άρνηση)"))
knitr::kable(data, caption = "Πίνακας 4.2: Τελεστές Λογικών Πράξεων")
```

Έστω για παράδειγμα ότι επιθυμούμε να πάρουμε τις τιμές εισοδήματος από τα άτομα με ηλικία άνω των 30 που έχουν χαμηλό μορφωτικό επίπεδο. Μπορούμε να διαμορφώσουμε έναν λογικό έλεγχο ως εξής:
```{r, echo=T}
(income_data$age<=30 & income_data$education=="basic")->x
income_data$income[x]
```
Οι παρενθέσεις δεν είναι απαραίτητες εδώ, αλλά είναι γενικά καλή πρακτική να χρησιμοποιούνται για να αποφεύγονται λογικά σφάλματα. 

### 4.3.4 Λήψη υποσυνόλων από πλαίσια δεδομένων με τη συνάρτηση $subset()$

Οι έλεγχοι που είδαμε παραπάνω επιστρέφουν ένα διάνυσμα λογικών τιμών το οποίο χρειάζεται να χρησιμοποιήσουμε σε επόμενο στάδιο για να κάνουμε λήψη του υποσυνόλου που πληροί τις προϋποθέσεις. Ένας εύκολος και πολύ ευέλικτος τρόπος να συνδυάσουμε λογικούς/αριθμητικούς ελέγχους με ταυτόχρονη λήψη του υποσυνόλου είναι η συνάρτηση $subset()$ η οποία δρα πάνω σε ένα dataframe με ταυτόχρονο "πέρασμα" των ελέγχων σαν δεύτερη παράμετρο. Αν για παράδειγμα επιθυμούμε τα δεδομένα του data_income για τα άτομα ηλίκιας κάτω των 30, θα γράψουμε:

```{r, echo=T}
subset(income_data, age<=30)
```

Όπως βλέπουμε το αποτέλεσμα είναι το σύνολο των μεταβλητών/διανυσμάτων του dataframe που ικανοποιούν τη συνθήκη. Αν δεν θέλουμε όλα τα διανύσματα μπορούμε να επιλέξουμε αυτά που θέλουμε:

```{r, echo=T}
subset(income_data, age<=30, c(income, education))
```

ή να εξαιρέσουμε αυτά που δεν θέλουμε:

```{r, echo=T}
subset(income_data, age<=30, -c(age, AgeClass))
```

Μπορούμε τέλος να συνδυάσουμε ελέγχους με τη χρήση των λογικών τελεστών σύνδεσης που είδαμε παραπάνω:

```{r, echo=T}
subset(income_data, age<=30 & education=="high", c(AgeClass, income, education))
```


### 4.3.5 Λήψη θέσεων στοιχείων υποσυνόλων με τη συνάρτηση which()

Η χρήση των ελέγχων για τη δημιουργία διανυσμάτων λογικών τιμών (ΤRUE/FALSE) όπως αναλύθηκε στις προηγούμενες ενότητες έχει έναν βασικό περιορισμό. Αυτός είναι ότι δεν επιτρέπει τον εύκολο χειρισμό των υποσυνόλων για περαιτέρω υπολογισμούς πάνω στο ίδιο dataframe. Για να καταλάβετε καλύτερα το πρόβλημα φανταστείτε το εξής ερώτημα: Θέλουμε να εντοπίσουμε το υποσύνολο των ατόμων με εισόδημα κάτω από 20 και να προσθέσουμε στις τιμές εισοδήματος ένα bonus (+2). Πώς θα κάνουμε κάτι τέτοιο;
Με την προσέγγιση λογικού ελέγχου, το διάνυσμα που επιστρέφεται μας επιτρέπει να πάρουμε τις τιμές που επιβεβαιώνουν τον έλεγχο αλλά δεν μπορούμε, (τουλάχιστον όχι με κάποιον απευθείας τρόπο) να χειριστούμε τις τιμές αυτές **μέσα** στο dataframe. Για να κάνουμε κάτι τέτοιο θα χρειαστούμε τις σχετικές θέσεις των στοιχείων μέσα στο πλαίσιο δεδομένων. Αυτό επιτυγχάνεται με το συνδυασμό λογικών ελέγχων στο πλαίσιο της συνάρτησης $which()$.

```{r, echo=T}
which(income_data$income<=20)->i
i
```

Βλέπουμε εδώ ότι το αποτέλεσμα της $which()$ δεν είναι ένα διάνυσμα λογικών τιμών αλλά ένα αριθμητικό διάνυσμα μικρότερου μήκους, το οποίο περιέχει τις θέσεις στο διάνυσμα $income$ για τις οποίες ικανοποιείται η συνθήκη ελέγχου (<=20). Μπορούμε τώρα εύκολα να αλλάξουμε τις τιμές μέσα στο $data_income$ με μια απλή πρόσθεση που όμως θα εφαρμοστεί μόνο στο υποσύνολο που ορίστηκε από την $which()$:

```{r, echo=T}
income_data$income;
income_data$income[i]<-income_data$income[i]+2
income_data$income;
```

Οι δύο εκτυπώσεις του $income$ διαφέρουν κατά +2 μόνο στις θέσεις που ήταν αρχικά <=20.
Η $which()$ μας επιτρέπει εκτός από πράξεις στο ίδιο το διάνυσμα που ελέγχεται να κάνουμε πράξεις και υπολογισμούς σε περισσότερα από ένα διανύσματα ή και σε ολόκληρο το dataframe. Με αυτόν τον τρόπο μπορούμε να δημιουργούμε κατά βούληση υποσύνολα σαν να είχαμε την ευχέρεια να χρησιμοποιήσουμε οποιαδήποτε κατηγοριοποίηση θέλουμε. 
Για να δούμε ένα παράδειγμα των δυνατοτήτων της $which()$ ας επιστρέψουμε στο ερώτημα που συζητήσαμε στην αρχή της ενότητας 4.3.1. Ας οργανώσουμε δηλαδή το dataframe με έναν ηλικιακό παράγοντα δύο επιπέδων (higher, lower) με όριο όμως τα 30, αντί για τα 35 χρόνια. Για να παρακολουθήσουμε τη διαδικασία καλύτερα, ας δούμε ποια είναι η συχνότητα των δύο κατηγοριών πριν την αλλαγή:
```{r, echo=T}
table(income_data$AgeClass)
```

Αυτό που θα πρέπει να κάνουμε είναι να πραγματοποιήσουμε αρχικά των έλεγχο με το νέο όριο και στη συνέχεια να αντικαταστήσουμε τις τιμές του παράγοντα $AgeClass$ με νέες τιμές με βάση αυτά τα όρια. Mε δύο συμπληρωματικές $which()$ δημιουργούμε τις λίστες θέσεων του $age$ που είναι κάτω και πάνω από το όριο.

```{r, echo=T}
which(income_data$age<=30)->lowage 
which(income_data$age>30)->highage
```

Στην συνέχεια χρησιμοποιούμε τις θέσεις αυτές για να μεταβάλλουμε τις αντίστοιχες τιμές του factor $AgeClass$:

```{r, echo=T}
income_data$AgeClass[lowage]<-"lower" 
income_data$AgeClass[highage]<-"higher"
```

Προσέξτε τα εισαγωγικά στις τιμές που αντικαθιστούμε, καθώς εφόσον μιλάμε για παράγοντα θα πρέπει πάντα να σκεφτόμαστε τον τύπο των δεδομένων ως σειρά χαρακτήρων.
Ας δούμε τώρα πώς έχουν οι συχνότητες των επιπέδων του $AgeClass$ μετά την αλλαγή των ορίων ηλικίας.

```{r, echo=T}
table(income_data$AgeClass)
```

Λογικά η αλλαγή έχει φέρει περισσότερα άτομα στην υψηλότερη ηλικιακή κατηγορία καθώς το όριο διάκρισης είναι πλέον χαμηλότερο. Το σύνολο των σχετικών τιμών του dataframe φαίνεται παρακάτω:

```{r, echo=T}
income_data[,c(2,4)]
```

όπου φαίνεται και η μετατροπή των ορίων με τις τιμές >=30 να χαρακτηρίζονται πλέον ως "higher".

## 4.4 Πράξεις σε σύνολα

Πέρα από τη δημιουργία υποσυνόλων και των συνδυασμό λογικών ελέγχων, πολύ συχνά χρειάζεται να πραγματοποιήσουμε πράξεις σε ήδη υπάρχοντα σύνολα. Η R υποστηρίζει όλες τις πράξεις της θεωρίας συνόλων που είναι οι: ένωση, τομή, συμπλήρωμα και διαφορές μεταξύ συνόλων με μια σειρά από συναρτήσεις που δρουν πάνω σε δύο σύνολα. Οι συναρτήσεις αυτές φαίνονται στον Πίνακα 4.3.  

```{r, echo=F, eval=T}
data<-data.frame(Συνάρτηση=c("union(a,b)","intersect(a,b)", "setdiff(a,b)","setdiff(b,a)", "setequal(a,b)"), Πράξη=c("Ένωση a, b","Τομή a, b", "Στοιχεία του a που δεν υπάρχουν στο b", "Στοιχεία του b που δεν υπάρχουν στο a", "'Ελεγχος ταύτισης συνόλων a, b"))
knitr::kable(data, caption = "Πίνακας 4.3: Συναρτήσεις Συνόλων")
```

Ας δούμε τις παραπάνω συναρτήσεις σε ένα παράδειγμα. Δημιουργούμε αρχικά δύο σειρές αριθμών που περιέχουν τους πρώτους 10 στη σειρά πρώτους αριθμούς (primes) και τους αντίστοιχους πρώτους δέκα όρους της ακολουθίας Fibonacci (fibonacci).

```{r, echo=T}
primes<-c(2,3,5,7,11,13,17,19,23,29)
fibonacci<-c(1,1,2,3,5,8,13,21,34,55)
```

Αρχικά θα συγκρίνουμε τα δύο σύνολα με την $setequal(a,b)$:

```{r, echo=T}
setequal(primes,fibonacci)
```

η οποία όπως βλέπουμε επιστρέφει μια λογική τιμή ανάλογα με το αν τα δύο σύνολα ταυτίζονται η όχι.
Στη συνέχεια με τις αντίστοιχες συναρτήσεις θα εξαγάγουμε την τομή και την ένωση των δύο συνόλων:

```{r, echo=T}
union(primes,fibonacci)
intersect(primes,fibonacci)
```

Προσέξτε ότι στο αποτέλεσμα της ένωσης το 1 εμφανίζεται μία φορά, ακόμα κι αν το διάνυσμα fibonacci περιείχε την τιμή δύο φορές. Τόσο η πράξη της τομής όσο και της ένωσης διενεργούνται σε **μοναδικές** τιμές των δύο συνόλων. 
Οι αντίστοιχες πράξεις που μας δίνουν τις διαφορές των δύο συνόλων είναι:

```{r, echo=T}
setdiff(primes,fibonacci)
setdiff(fibonacci, primes)
```

οι οποίες μας επιστρέφουν κι εδώ τα μοναδικά μη-κοινά στοιχεία του κάθε συνόλου.
Πώς θα πάρει κανείς το σύνολο των στοιχείων που διαφέρουν μεταξύ δύο συνόλων; Υπάρχουν περισσότεροι από ένας τρόποι για να το κάνει συνδυάζοντας τις παραπάνω συναρτήσεις. Αρκεί να ενώσει τα δύο διανύσματα των δυό συμπληρωματικών $setdiff()$ κλήσεων σε ένα διάνυσμα:

```{r, echo=T}
c(setdiff(primes,fibonacci),setdiff(fibonacci, primes))
```

Eναλλακτικά, μπορεί αν ζητήσει τη διαφορά των συνόλων που ορίζονται από την ένωση και την τομή των δύο αρχικών συνόλων:
```{r, echo=T}
setdiff(union(primes,fibonacci), intersect(primes,fibonacci))
```


### 4.4.1 Ύπαρξη στοιχείων συνόλου σε άλλο σύνολο

Οι συναρτήσεις $intersect()$ και $setdiff()$ μας δίνουν τα κοινά και τα διαφορετικά στοιχεία δύο συνόλων. Τι συμβαίνει όμως όταν δεν μας ενδιαφέρουν μόνο οι τιμές αλλά και οι θέσεις των στοιχείων του ενός συνόλου μέσα στο άλλο;
Για το σκοπό αυτό, έχουμε δει ήδη την συνάρτηση $is.element(a,b)$ η οποία ελέγχει την τομή των $a, b$ αλλά επιστρέφει ένα διάνυσμα μήκους ίσου με του διάνυσματος $a$ με λογικές τιμές TRUE/FALSE που προκύπτουν από τον έλεγχο του κάθε στοιχείου του $a$ εντός του $b$. Έτσι ο έλεγχος:

```{r, echo=T}
is.element(primes,fibonacci)
```

Οι τιμές αντιστοιχούν στον έλεγχο κάθε τιμής του $a$ για ύπαρξη εντός του $b$. Έτσι π.χ. οι τρεις πρώτοι πρώτοι αριθμοί (2,3,5) είναι και όροι της ακολουθίας Fibonacci και συνεπώς παίρνουν την τιμή TRUE, κ.ο.κ. Προσέξτε τι συμβαίνει με το αντίθετο:

```{r, echo=T}
is.element(fibonacci, primes)
```

Εδώ οι δύο πρώτες τιμές είναι και οι δύο FALSE και αναφέρονται στη μη ύπαρξη της τιμής 1 στην ακολουθία των πρώτων. Σε αντίθεση δηλαδή με τις συναρτήσεις που είδαμε παραπάνω, η $is.element(a,b)$ λαμβάνει υπόψιν τις πολλαπλότητες τιμών. Ας δούμε καλύτερα αυτήν την μικρή αλλά σημαντική λεπτομέρεια αλλάζοντας λίγο το ένα από τα δύο σύνολα, προσθέτοντας το 1 στους πρώτους:

```{r, echo=T}
extended_primes<-c(1,2,3,5,7,11,13,17,19,23,29)
is.element(fibonacci, extended_primes)
```
Βλέπουμε ότι από τη στιγμή που η τιμή 1 βρίσκεται στους νέους $extended_primes$ η $is.element()$ επιστρέφει την τιμή TRUE δύο φορές, κάνοντας δηλαδή τη σύγκριση όσες φορές το 1 υπάρχει στο διάνυσμα $fibonacci$.

### 4.4.2 Συγκρίσεις μεταξύ συνόλων σε επίπεδο θέσης

Το ίδιο αποτέλεσμα με την $is.element(a,b)$ μπορεί κανείς να πετύχει με τον τελεστή %in% όπως φαίνεται στο παράδειγμα:

```{r, echo=T}
is.element(fibonacci, extended_primes)
fibonacci %in% extended_primes
```

Η μοναδική διαφορά μεταξύ των δύο είναι ότι ο δεύτερος υπολογισμός γίνεται μέσω ενός τελεστή και εκτελείται ταχύτερα, συνεπώς προτιμάται σε μεγάλα σύνολα.
H βασική χρησιμότητα της χρήσης του τελεστή έγκειται στο συνδυασμό του με την $which()$. Με τρόπο ανάλογο με αυτόν που είδαμε παραπάνω μπορούμε να εντοπίσουμε τις θέσεις μέσα σε ένα διάνυσμα που περιέχουν κοινές τιμές με ένα άλλο εφαρμόζοντας τον ελέγχο που είδαμε παραπάνω ως εξής:

```{r, echo=T}
which(fibonacci %in% primes==T)->j
j
```

το διάνυσμα j περιέχει τις **θέσεις** του fibonacci που περιέχουν πρώτους αριθμούς. Αν θέλουμε τις αντίστοιχες θέσεις που δεν περιέχουν πρώτους, δεν έχουμε παρά να αντιστρέψουμε τον έλεγχο:

```{r, echo=T}
which(fibonacci %in% primes==F)->k
k
```

κι έτσι οι πρώτοι και μη-πρώτοι όροι του διανύσματος fibonacci είναι:

```{r, echo=T}
fibonacci[j]
fibonacci[k]
```

## Συμπεράσματα
Στο σημείο αυτό έχουμε καλύψει το σύνολο των τύπων δεδομένων και των βασικών αλλά και αρκετών προχωρημένων χειρισμών τους. Τι μπορούμε πλέον να κάνουμε με τα δεδομένα με βάση όσα έχουμε μάθει; Ένας κανόνας που θα πρέπει να θυμόμαστε ως αναλυτές δεδομένων είναι ότι είναι πάντα πολύ σημαντικό να εξετάζουμε οπτικά τα δεδομένα μας μέσω γραφικής αναπαράστασής τους. Η R διαθέτει μια σειρά από συναρτήσεις και λειτουργίες που επιτρέπουν τη δημιουργία πλούσιων πληροφοριακά αλλά και αισθητικά γραφικών παραστάσεων. Στο επόμενο, τελευταίο Κεφάλαιο αυτού του πρώτου μέρους θα δούμε πώς μπορούμε να χρησιμοποιήσουμε την R για την γραφική αναπαράσταση δεδομένων. 

